package de.rwth.dfa.jvm.samples; // Generated package name

//import de.fub.bytecode.classfile.*;
//import de.fub.bytecode.generic.*;
import org.apache.bcel.classfile.*;
import org.apache.bcel.generic.*;
import de.rwth.domains.*;
import de.rwth.domains.templates.*;

import de.rwth.dfa.jvm.*;

/**
 * Implementation of a live variables abstraction. It can be used to determine the
 * dead local variable slots for each instruction of a JVM method. The domain used is
 * a {@link BitVectorLattice} with one bit for each slot. If the bit is not set in
 * the result, then the slot is definitely dead. If it is set, the slot may be live
 * or not.
 *
 * @author <a href="mailto:M.Mohnen@gmx.de">Markus Mohnen</a>
 * @version $Id: LVAbstraction.java,v 1.4 2002/09/17 06:53:53 mohnen Exp $
 */
public class LVAbstraction implements Abstraction {
  /**
   * The lattice of this abstraction.
   *
   */
  protected BitVectorLattice b = null;

  /**
   * Creates a new <code>LVAbstraction</code> instance.
   *
   * @param maxLocals an <code>int</code> value: The maximal number of used slots in
   * the method.
   */
  public LVAbstraction(int maxLocals) {
    super();
    this.b = new BitVectorLattice(maxLocals);
  }

  /**
   * Creates a new <code>LVAbstraction</code> instance.
   *
   * @param m a <code>Method</code> value
   */
  public LVAbstraction(Method m) {
    this(m.getCode().getMaxLocals());
  }

  /**
   * Returns the lattice of this abstraction.
   *
   * @return a <code>Lattice</code> value
   */
  public Lattice getLattice() { return b; }

  /**
   * Returns the bottom element of the lattice where all bits are not set.
   *
   * @param ih an <code>InstructionHandle</code> value
   * @param isRoot a <code>boolean</code> value
   * @return an <code>Object</code> value
   */
  public Object getInitialValue(InstructionHandle ih, boolean isRoot) {
    return b.bottom();
  }
  
  /**
   * Returns <code>DIRECTION_BACKWARD</code>.
   *
   * @return an <code>int</code> value
   */
  public int getDirection() { return DIRECTION_BACKWARD; }

  /**
   * Returns <code>QUANTIFIER_EXISTS</code>.
   *
   * @return an <code>int</code> value
   */
  public int getQuantifier() { return QUANTIFIER_EXISTS; }
  
  /**
   * Returns a {@link KillGenBitVectorFunction} for an instruction. The bits for
   * those slots which are made dead (by overwriting the value) are killed, those
   * which are made live (by accessing the value) are generated by the function.
   * 
   * @param ih an <code>InstructionHandle</code> value
   * @return a <code>Function</code> value
   */
  public Function getAbstract(InstructionHandle ih) {
    Instruction i = ih.getInstruction();
    Function f = null;
    try {
      if (i instanceof IINC) {
	/* Actually, this is already an optimisation. Note that IINC
	   is equivalent to LOAD; ADD; STORE but the abstraction is
	   not.  However, this is better since an INC is only useful
	   if the value is not dead at that point. Hence, an INC
	   neither kills not gens variables.
	   f = new IdentityFunction(b);
	*/
	IINC ii = (IINC)i;
	f = new KillGenBitVectorFunction(b,
					 new int[] {ii.getIndex()},
					 new int[] {ii.getIndex()});
      } else if (i instanceof LocalVariableInstruction) {
	LocalVariableInstruction li = (LocalVariableInstruction)i;
	if (li instanceof ALOAD ||
	    li instanceof DLOAD ||
	    li instanceof FLOAD ||
	    li instanceof ILOAD ||
	    li instanceof LLOAD) {
	  f = new KillGenBitVectorFunction(b, new int[0],
					   new int[] {li.getIndex()});
	} else {
	  f = new KillGenBitVectorFunction(b,new int[] {li.getIndex()}, new int[0]);
	}
      } else if (i instanceof RET) {
	f = new KillGenBitVectorFunction(b, new int[0],
					 new int[] {((RET)i).getIndex()});
      } else if (i instanceof IINC) {
	/* Actually, this is already an optimisation. Note that IINC
	   is equivalent to LOAD; ADD; STORE but the abstraction is
	   not.  However, this is better since an INC is only useful
	   if the value is not dead at that point. Hence, an INC
	   neither kills not gens variables.
	   f = new IdentityFunction(b);
	*/
	IINC ii = (IINC)i;
	f = new KillGenBitVectorFunction(b,
					 new int[] {ii.getIndex()},
					 new int[] {ii.getIndex()});
      } else {
	f = new KillGenBitVectorFunction(b, new int[] {}, new int[] {});
      }
      return f;
    } catch (Exception ex) {
      throw new Error(ex.toString());
    }
  }

  /**
   * Returns the value of the default implementation in {@link Abstraction.Default}.
   *
   * @param ihv an <code>InstructionHandleVector</code> value
   * @param isRoot a <code>boolean</code> value
   * @return an <code>Object</code> value
   */
  public Object getInitialValue(InstructionHandleVector ihv, boolean isRoot) {
    return Abstraction.Default.getInitialValue(this, ihv, isRoot);
  }
  
  /**
   * Returns a new {@link KillGenBitVectorFunction} for a vector of
   * instructions. This is much more efficient than using the default implementation
   * in {@link Abstraction.Default}.
   *
   * @param ihv an <code>InstructionHandleVector</code> value
   * @return a <code>Function</code> value
   */
  public Function getAbstract(InstructionHandleVector ihv) {
    KillGenBitVectorFunction f =
      (KillGenBitVectorFunction)getAbstract((InstructionHandle)ihv.elementAt(ihv.size()-1));
    for (int i=ihv.size()-2; i>=0; i--) {
      f=new KillGenBitVectorFunction((KillGenBitVectorFunction)getAbstract((InstructionHandle)ihv.elementAt(i)),
				     f);
    }
    return f;
  }
}

